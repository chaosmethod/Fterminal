<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=240, initial-scale=1.0">
    <title>Fallout Terminal Hacking Game for Rabbit r1</title>
    <style>
        body {
            background-color: black;
            color: limegreen;
            font-family: monospace;
            font-size: 10px;
            margin: 0;
            padding: 5px;
            width: 240px;
            height: 282px;
            overflow: hidden;
            box-sizing: border-box;
        }
        #terminal {
            white-space: pre;
            line-height: 1.0;
            pointer-events: none; /* Disable touchscreen during gameplay */
            height: 220px;
            overflow: hidden;
        }
        .highlight {
            background-color: limegreen;
            color: black;
        }
        #status {
            margin-top: 5px;
            height: 20px;
        }
        #new-game {
            display: none;
            pointer-events: auto; /* Enable touch for new game prompt */
            align-items: center;
            justify-content: center;
        }
        #new-game span {
            margin-right: 15px;
        }
        button {
            background-color: black;
            color: limegreen;
            border: 1px solid limegreen;
            font-family: monospace;
            min-width: 44px; /* Minimum touch target size */
            min-height: 44px;
        }
        span {
            display: inline-block;
            width: 10px; /* Approximate char width */
        }
    </style>
</head>
<body>
    <div id="terminal"></div>
    <div id="status"></div>
    <div id="new-game">
        <span>Play again?</span>
        <button id="yes">[Yes]</button>
        <button id="no">[No]</button>
    </div>

    <script>
        // Game configuration adjusted for 240x282px
        const WORD_LENGTH = 7;
        const NUM_WORDS = 12; // Increased slightly for more wrong answers to waste turns
        const ATTEMPTS = 5;
        const LINES = 18; // Reduced to fit height
        const CHARS_PER_LINE = 24; // Reduced to fit width (~240px at 10px font)

        // Expanded word list with 7-letter words
        const WORDS = [
            "ACCESSX", "DENIEDX", "SYSTEMS", "HACKERS", "TERMINS", "VAULTSS", "FALLOUT",
            "NUCLEAR", "RADIATE", "MUTANTS", "PIPBOYS", "BROTHER", "ENCLAVE", "SUPERMS",
            "WASTELD", "RAIDERS", "GHOULSS", "BOSHOOD", "VAULT13", "OVERSEE", "PIP2000"
        ];

        let password;
        let attemptsLeft = ATTEMPTS;
        let terminalText = [];
        let selectableItems = []; // {type: 'word' or 'dud', startPos, endPos, value, position: {line, start, end}}
        let highlightIndex = 0; // Global position
        const TOTAL_CHARS = LINES * CHARS_PER_LINE;
        let isSpecialMessage = false;

        function generatePuzzle() {
            // Select password
            password = WORDS[Math.floor(Math.random() * WORDS.length)];

            // Select other words (wrong answers to waste turns)
            let words = [password];
            while (words.length < NUM_WORDS) {
                let w = WORDS[Math.floor(Math.random() * WORDS.length)];
                if (!words.includes(w)) words.push(w);
            }

            // Generate garbage characters
            let garbageChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`'.split('');

            // Build terminal lines with fully random characters
            terminalText = [];
            for (let i = 0; i < LINES; i++) {
                let line = '';
                for (let j = 0; j < CHARS_PER_LINE; j++) {
                    line += garbageChars[Math.floor(Math.random() * garbageChars.length)];
                }
                terminalText.push(line);
            }

            // Insert words and duds
            selectableItems = [];
            words.forEach(word => {
                insertItem(word, 'word', word);
            });
            // Add duds: pairs like () [] {} with garbage inside
            for (let k = 0; k < Math.floor(NUM_WORDS / 2); k++) { // A few duds
                let dudPair = ['()', '[]', '{}'][Math.floor(Math.random() * 3)];
                let dudLength = Math.floor(Math.random() * 5) + 2; // Garbage inside length
                let dudContent = dudPair[0];
                for (let m = 0; m < dudLength; m++) {
                    dudContent += garbageChars[Math.floor(Math.random() * garbageChars.length)];
                }
                dudContent += dudPair[1];
                insertItem(dudContent, 'dud', dudContent);
            }

            renderTerminal();
            updateStatus(`Attempts left: ${attemptsLeft}`);
        }

        function insertItem(item, type, value) {
            let inserted = false;
            while (!inserted) {
                let lineIdx = Math.floor(Math.random() * LINES);
                let start = Math.floor(Math.random() * (CHARS_PER_LINE - item.length));
                let canInsert = true;
                for (let ex of selectableItems) {
                    if (ex.position.line === lineIdx && Math.max(start, ex.position.start) < Math.min(start + item.length, ex.position.end)) {
                        canInsert = false;
                        break;
                    }
                }
                if (canInsert) {
                    let line = terminalText[lineIdx];
                    terminalText[lineIdx] = line.substring(0, start) + item + line.substring(start + item.length);
                    let startPos = lineIdx * CHARS_PER_LINE + start;
                    selectableItems.push({type, position: {line: lineIdx, start, end: start + item.length}, startPos, endPos: startPos + item.length, value});
                    inserted = true;
                }
            }
        }

        function renderTerminal() {
            let html = '';
            let globalPos = 0;
            terminalText.forEach((line, idx) => {
                for (let c = 0; c < CHARS_PER_LINE; c++) {
                    html += `<span id="char-${globalPos}">${line[c]}</span>`;
                    globalPos++;
                }
                html += '\n';
            });
            document.getElementById('terminal').innerHTML = html;
            highlightItem();
        }

        function highlightItem() {
            document.querySelectorAll('span').forEach(sp => sp.classList.remove('highlight'));
            if (highlightIndex < 0) highlightIndex = TOTAL_CHARS - 1;
            if (highlightIndex >= TOTAL_CHARS) highlightIndex = 0;
            let line = Math.floor(highlightIndex / CHARS_PER_LINE);
            let col = highlightIndex % CHARS_PER_LINE;
            let curPos = highlightIndex;
            let curSpanId = line * CHARS_PER_LINE + col;
            let currentItem = null;
            for (let item of selectableItems) {
                if (curPos >= item.startPos && curPos < item.endPos) {
                    currentItem = item;
                    break;
                }
            }
            if (currentItem) {
                // Highlight whole word or dud set
                let itemLine = currentItem.position.line;
                let itemStartCol = currentItem.position.start;
                let itemEndCol = currentItem.position.end;
                for (let p = itemStartCol; p < itemEndCol; p++) {
                    let spanId = itemLine * CHARS_PER_LINE + p;
                    document.getElementById(`char-${spanId}`).classList.add('highlight');
                }
            } else {
                // Highlight single character
                document.getElementById(`char-${curSpanId}`).classList.add('highlight');
            }
        }

        function moveHighlight(direction) {
            if (isSpecialMessage) {
                updateStatus(`Attempts left: ${attemptsLeft}`);
                isSpecialMessage = false;
            }
            highlightIndex += direction;
            highlightItem();
        }

        function select() {
            if (attemptsLeft <= 0) return;
            let curPos = highlightIndex;
            let currentItem = null;
            for (let item of selectableItems) {
                if (curPos >= item.startPos && curPos < item.endPos) {
                    currentItem = item;
                    break;
                }
            }
            if (currentItem) {
                if (currentItem.type === 'word') {
                    if (currentItem.value === password) {
                        updateStatus('Access Granted!');
                        endGame();
                    } else {
                        attemptsLeft--;
                        let likeness = 0;
                        for (let i = 0; i < WORD_LENGTH; i++) {
                            if (currentItem.value[i] === password[i]) likeness++;
                        }
                        updateStatus(`Likeness: ${likeness}/${WORD_LENGTH} | Attempts left: ${attemptsLeft}`);
                        if (attemptsLeft === 0) {
                            updateStatus('Terminal Locked!');
                            endGame();
                        }
                    }
                } else if (currentItem.type === 'dud') {
                    // Remove a random wrong word or reset attempt
                    let action = Math.random() > 0.5 ? 'remove' : 'reset';
                    if (action === 'remove') {
                        let wrongWords = selectableItems.filter(it => it.type === 'word' && it.value !== password);
                        if (wrongWords.length > 0) {
                            let removeItem = wrongWords[Math.floor(Math.random() * wrongWords.length)];
                            // Remove from selectable
                            selectableItems = selectableItems.filter(it => it !== removeItem);
                            // Clear from text
                            let garbage = '';
                            for (let g = 0; g < removeItem.value.length; g++) {
                                garbage += '.';
                            }
                            let lineIdx = removeItem.position.line;
                            let start = removeItem.position.start;
                            terminalText[lineIdx] = terminalText[lineIdx].substring(0, start) + garbage + terminalText[lineIdx].substring(start + removeItem.value.length);
                            updateStatus('Dud removed an entry.');
                            isSpecialMessage = true;
                        }
                    } else {
                        attemptsLeft = Math.min(ATTEMPTS, attemptsLeft + 1);
                        updateStatus('Dud reset an attempt.');
                        isSpecialMessage = true;
                    }
                    // Remove the dud itself
                    selectableItems = selectableItems.filter(it => it !== currentItem);
                    let dudGarbage = '';
                    for (let g = 0; g < currentItem.value.length; g++) {
                        dudGarbage += '.';
                    }
                    let dudLineIdx = currentItem.position.line;
                    let dudStart = currentItem.position.start;
                    terminalText[dudLineIdx] = terminalText[dudLineIdx].substring(0, dudStart) + dudGarbage + terminalText[dudLineIdx].substring(dudStart + currentItem.value.length);
                    renderTerminal();
                }
            } else {
                // Selecting on garbage wastes a turn (to "throw random selections")
                attemptsLeft--;
                updateStatus(`Invalid selection. Attempts left: ${attemptsLeft}`);
                if (attemptsLeft === 0) {
                    updateStatus('Terminal Locked!');
                    endGame();
                }
            }
            renderTerminal();
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function endGame() {
            document.getElementById('terminal').style.pointerEvents = 'none';
            document.getElementById('new-game').style.display = 'flex';
        }

        // Rabbit r1 event listeners
        window.addEventListener('scrollUp', () => {
            moveHighlight(-1);
        });

        window.addEventListener('scrollDown', () => {
            moveHighlight(1);
        });

        window.addEventListener('sideClick', () => {
            select();
        });

        // New game buttons (touch enabled)
        document.getElementById('yes').addEventListener('click', () => {
            document.getElementById('new-game').style.display = 'none';
            document.getElementById('terminal').style.pointerEvents = 'none'; // Re-disable touch
            attemptsLeft = ATTEMPTS;
            highlightIndex = 0;
            generatePuzzle();
        });

        document.getElementById('no').addEventListener('click', () => {
            updateStatus('Game Over.');
            // Optionally close the webview if desired
            // closeWebView.postMessage();
        });

        // Start game
        generatePuzzle();
    </script>
</body>
</html>
